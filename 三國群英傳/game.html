<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>三國群英傳風格戰鬥模擬</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+TC:wght@700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Noto Serif TC', serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 160px;
            background: linear-gradient(to bottom, #1a1a1a, #000);
            border-top: 4px solid #cfb53b; /* Gold border */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
            box-sizing: border-box;
            z-index: 10;
        }

        /* General Info Box */
        .general-box {
            width: 300px;
            height: 100%;
            display: flex;
            align-items: center;
            position: relative;
        }

        .portrait {
            width: 100px;
            height: 100px;
            border: 3px solid #cfb53b;
            background-color: #333;
            overflow: hidden;
            position: relative;
        }
        
        .portrait img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Procedural Portrait Canvas */
        .portrait canvas {
            width: 100%;
            height: 100%;
        }

        .stats {
            flex: 1;
            padding: 0 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .name-tag {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 24px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 5px;
        }

        .bar-container {
            width: 100%;
            height: 12px;
            background: #333;
            border: 1px solid #555;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.2s;
        }

        .hp-fill { background: linear-gradient(to right, #cc0000, #ff4d4d); }
        .mp-fill { background: linear-gradient(to right, #0000cc, #4d4dff); }

        .count-text {
            color: #cfb53b;
            font-size: 14px;
            text-align: right;
            margin-top: 2px;
        }

        /* Center Timer */
        .center-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 150px;
            height: 100%;
            background: #222;
            border-left: 2px solid #555;
            border-right: 2px solid #555;
        }

        .timer-box {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 48px;
            color: #fff;
            text-shadow: 0 0 10px #cfb53b;
        }

        .timer-label {
            font-size: 16px;
            color: #cfb53b;
        }

        /* Top Menu Button */
        #menu-btn {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #cfb53b;
            color: #cfb53b;
            padding: 8px 24px;
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 0 10px #000;
            transition: all 0.2s;
        }
        
        #menu-btn:hover {
            background: #cfb53b;
            color: #000;
        }

        /* Command Overlay (Slow Mo Menu) */
        #command-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5); /* Semi-transparent black */
            backdrop-filter: blur(2px);
            z-index: 30;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #command-overlay.active {
            display: flex;
        }
        
        .menu-title {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 48px;
            color: #cfb53b;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #000;
        }

        .command-row {
            display: flex;
            gap: 20px;
        }

        .cmd-btn {
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid #cfb53b;
            color: #cfb53b;
            padding: 15px 30px;
            font-family: 'Noto Serif TC', serif;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 1px 1px 0 #000;
            min-width: 120px;
            text-align: center;
        }

        .cmd-btn:hover {
            background: #cfb53b;
            color: #000;
            transform: scale(1.1);
        }
        
        .skill-btn {
            border-color: #00ccff;
            color: #00ccff;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.3);
        }
        
        .skill-btn:hover {
            background: #00ccff;
            color: #000;
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.6);
        }

        /* Floating Damage Text */
        .floating-text {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 18px;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000;
            animation: floatUp 1s forwards;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.2); opacity: 0; }
        }

        /* Cutscene Overlay */
        #cutscene-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: none;
        }

        .skill-name {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 80px;
            color: yellow;
            text-shadow: 4px 4px 0 red, -2px -2px 0 #000;
            animation: skillZoom 2s ease-out;
        }

        @keyframes skillZoom {
            0% { transform: scale(0); opacity: 0; }
            10% { transform: scale(1.2); opacity: 1; }
            20% { transform: scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: scale(1.5); }
        }
        
        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .battle-start-text {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 100px;
            color: #ff3333;
            text-shadow: 0 0 20px #fff, 5px 5px 0 #000;
        }
        
        .hint-text {
            position: absolute;
            bottom: 170px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 14px;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="hint-text">按 [空白鍵] 或上方按鈕開啟指揮選單</div>

    <button id="menu-btn" onclick="game.toggleMenu()">軍 令</button>

    <!-- Command Overlay (Pause/SlowMo Menu) -->
    <div id="command-overlay" onclick="game.toggleMenu()">
        <div class="menu-title" onclick="event.stopPropagation()">軍令指揮</div>
        <div class="command-row" onclick="event.stopPropagation()">
            <button class="cmd-btn" onclick="game.sendCommand('charge'); game.toggleMenu()">全軍突擊</button>
            <button class="cmd-btn" onclick="game.sendCommand('hold'); game.toggleMenu()">原地待命</button>
            <button class="cmd-btn" onclick="game.sendCommand('retreat'); game.toggleMenu()">全軍後退</button>
        </div>
        <div class="command-row" style="margin-top: 20px;" onclick="event.stopPropagation()">
            <button class="cmd-btn skill-btn" onclick="game.castSkill(); game.toggleMenu()">武將技：半月斬</button>
        </div>
        <div style="margin-top: 30px; color: #888; font-size: 14px;">點擊空白處或按空白鍵返回戰鬥</div>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <!-- Player Stats (Left) -->
        <div class="general-box">
            <div class="portrait">
                <canvas id="p1-portrait"></canvas>
            </div>
            <div class="stats">
                <div class="name-tag">張 飛</div>
                <div class="bar-container"><div class="bar-fill hp-fill" id="p1-hp" style="width: 100%;"></div></div>
                <div class="count-text">HP <span id="p1-hp-text">500</span></div>
                <div class="bar-container"><div class="bar-fill mp-fill" id="p1-mp" style="width: 100%;"></div></div>
                <div class="count-text">兵 <span id="p1-troops">25</span></div>
            </div>
        </div>

        <!-- Center Timer -->
        <div class="center-panel">
            <div class="timer-label">剩餘時間</div>
            <div class="timer-box" id="timer">99</div>
        </div>

        <!-- Enemy Stats (Right) -->
        <div class="general-box" style="flex-direction: row-reverse; text-align: right;">
            <div class="portrait">
                <canvas id="p2-portrait"></canvas>
            </div>
            <div class="stats">
                <div class="name-tag">呂 布</div>
                <div class="bar-container"><div class="bar-fill hp-fill" id="p2-hp" style="width: 100%;"></div></div>
                <div class="count-text">HP <span id="p2-hp-text">800</span></div>
                <div class="bar-container"><div class="bar-fill mp-fill" id="p2-mp" style="width: 100%;"></div></div>
                <div class="count-text">兵 <span id="p2-troops">25</span></div>
            </div>
        </div>
    </div>

    <!-- Cutscene -->
    <div id="cutscene-overlay">
        <div class="skill-name" id="skill-text">半月斬</div>
    </div>
    
    <div id="start-overlay">
        <div class="battle-start-text">戰鬥開始</div>
    </div>
</div>

<script>
/**
 * Game Configuration & Assets
 */
const CONFIG = {
    groundY: 0, // Calculated dynamically
    worldWidth: 2000,
    cameraSpeed: 10,
    colors: {
        player: '#4488ff', // Blue
        playerSkin: '#ffccaa',
        playerArmor: '#0044aa',
        enemy: '#ff4444', // Red
        enemySkin: '#ffccaa',
        enemyArmor: '#880000',
        hpBar: '#00ff00',
        bgSky: '#66aacc',
        bgGround: '#8b5a2b',
        bgGrass: '#4a7023'
    }
};

/**
 * Classes
 */
class Camera {
    constructor(width, height) {
        this.x = 0;
        this.y = 0;
        this.width = width;
        this.height = height;
        this.targetX = 0;
        this.isDragging = false;
        this.lastMouseX = 0;
    }

    update() {
        // Smooth follow or clamp
        this.x = Math.max(0, Math.min(this.x, CONFIG.worldWidth - this.width));
    }
}

class Projectile {
    constructor(x, y, tx, ty, team) {
        this.x = x;
        this.y = y;
        this.startX = x;
        this.startY = y;
        this.targetX = tx;
        this.targetY = ty;
        this.team = team;
        this.life = 60;
        this.progress = 0;
        this.speed = 0.03; // progress per frame
        this.arcHeight = 150;
    }

    update(gameSpeed) {
        this.progress += this.speed * gameSpeed;
        if (this.progress >= 1) {
            this.life = 0;
            return true; // Hit
        }

        // Linear interpolation for X
        this.x = this.startX + (this.targetX - this.startX) * this.progress;
        
        // Parabolic interpolation for Y
        const linearY = this.startY + (this.targetY - this.startY) * this.progress;
        const arc = 4 * this.arcHeight * this.progress * (1 - this.progress);
        this.y = linearY - arc;
        
        return false;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Rotate arrow to follow trajectory
        // Derivative of y approx
        const dx = (this.targetX - this.startX);
        const dy = (this.targetY - this.startY) - 4 * this.arcHeight * (1 - 2 * this.progress);
        const angle = Math.atan2(dy, dx);
        
        ctx.rotate(angle);
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(-10, -1, 20, 2);
        ctx.fillStyle = '#888';
        ctx.fillRect(8, -2, 4, 4); // Arrowhead

        ctx.restore();
    }
}

class Entity {
    constructor(x, y, team, type = 'infantry') {
        this.x = x;
        this.y = y;
        this.z = y; // Depth sorting
        this.team = team; // 1 = Player, 2 = Enemy
        this.type = type; // infantry, archer, general
        this.vx = 0;
        this.vy = 0;
        this.speed = (1 + Math.random() * 0.5) * (type === 'archer' ? 0.8 : 1);
        this.state = 'idle'; // idle, move, attack, dead
        this.hp = type === 'archer' ? 15 : 20;
        this.maxHp = this.hp;
        this.target = null;
        this.attackRange = type === 'archer' ? 300 : 40;
        this.attackCooldown = 0;
        this.attackSpeed = type === 'archer' ? 120 : 60; // Archers slower
        this.animFrame = 0;
        this.width = 30;
        this.height = 50;
        this.dead = false;
        this.command = 'charge'; 
    }

    update(entities, gameSpeed) {
        if (this.dead) return;

        // Command Override (Generals handle their own, but units follow)
        if (this.type !== 'general' && this.team === 1) {
            if (this.command === 'hold') {
                this.state = 'idle';
                this.target = null;
                return;
            } else if (this.command === 'retreat') {
                this.vx = -this.speed;
                this.x += this.vx * gameSpeed;
                this.animFrame += gameSpeed;
                return;
            }
        }

        // AI Logic
        if (!this.target || this.target.dead) {
            this.findTarget(entities);
        }

        if (this.target) {
            const dx = this.target.x - this.x;
            const dy = this.target.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < this.attackRange) {
                // Attack
                this.state = 'attack';
                this.attackCooldown -= gameSpeed;
                if (this.attackCooldown <= 0) {
                    this.attack();
                    this.attackCooldown = this.attackSpeed;
                }
            } else {
                // Move towards
                this.state = 'move';
                
                // Archers maintain distance if too close? simplified: just stop at max range
                const angle = Math.atan2(dy, dx);
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * (this.speed * 0.5); 
                
                this.x += this.vx * gameSpeed;
                this.y += this.vy * gameSpeed;
                this.animFrame += gameSpeed;
            }
        } else {
            // No target, move forward
            this.state = 'move';
            this.vx = (this.team === 1 ? 1 : -1) * this.speed;
            this.x += this.vx * gameSpeed;
            this.animFrame += gameSpeed;
        }
        
        // Boundaries
        if(this.y < CONFIG.groundY - 100) this.y = CONFIG.groundY - 100;
        if(this.y > CONFIG.groundY + 100) this.y = CONFIG.groundY + 100;
    }

    findTarget(entities) {
        let closest = null;
        let minDist = 2000;
        
        for (let e of entities) {
            if (e.team !== this.team && !e.dead) {
                const dist = Math.abs(e.x - this.x);
                if (dist < minDist) {
                    minDist = dist;
                    closest = e;
                }
            }
        }
        this.target = closest;
    }

    attack() {
        if (this.target) {
            if (this.type === 'archer') {
                game.spawnProjectile(this.x, this.y - 30, this.target.x, this.target.y, this.team);
            } else {
                // Melee
                const dmg = 5 + Math.floor(Math.random() * 5);
                this.target.takeDamage(dmg);
            }
            this.animFrame = 0; 
        }
    }

    takeDamage(amount) {
        this.hp -= amount;
        game.addFloatingText(this.x, this.y - 60, `-${amount}`, '#ff0000');
        if (this.hp <= 0) {
            this.dead = true;
            this.state = 'dead';
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        const dir = (this.target) ? (this.target.x > this.x ? 1 : -1) : (this.team === 1 ? 1 : -1);
        ctx.scale(dir, 1);

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(0, 0, 15, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        if (this.dead) {
            ctx.rotate(Math.PI / 2);
            ctx.globalAlpha = 0.5;
        }

        const bounce = this.state === 'move' ? Math.sin(this.animFrame * 0.2) * 2 : 0;
        const attackAnim = this.state === 'attack' && this.attackCooldown > (this.attackSpeed - 15) ? 10 : 0;
        
        // Legs
        ctx.fillStyle = '#111';
        ctx.fillRect(-5 + bounce, -15, 4, 15);
        ctx.fillRect(5 - bounce, -15, 4, 15);

        // Torso
        ctx.fillStyle = this.team === 1 ? CONFIG.colors.playerArmor : CONFIG.colors.enemyArmor;
        ctx.fillRect(-8, -35 + bounce, 16, 25);
        
        // Head
        ctx.fillStyle = this.team === 1 ? CONFIG.colors.playerSkin : CONFIG.colors.enemySkin;
        ctx.fillRect(-6, -45 + bounce, 12, 12);
        
        // Helmet (Archer difference)
        if (this.type === 'archer') {
             ctx.fillStyle = '#654'; // Leather cap
             ctx.fillRect(-7, -46 + bounce, 14, 4);
        } else {
             ctx.fillStyle = '#555'; // Metal helm
             ctx.fillRect(-7, -48 + bounce, 14, 5);
             ctx.fillStyle = this.team === 1 ? 'blue' : 'red';
             ctx.fillRect(0, -52 + bounce, 2, 4);
        }

        // Weapon
        ctx.fillStyle = '#888';
        if (this.type === 'archer') {
             // Draw Bow
             ctx.strokeStyle = '#852';
             ctx.lineWidth = 2;
             ctx.beginPath();
             if (this.state === 'attack' && attackAnim > 0) {
                 // Shooting
                 ctx.arc(5, -30 + bounce, 10, -Math.PI/2, Math.PI/2);
             } else {
                 // Holding
                 ctx.arc(5, -30 + bounce, 10, -Math.PI/2, Math.PI/2);
             }
             ctx.stroke();
        } else {
            // Spear
            if (this.state === 'attack') {
                ctx.save();
                ctx.translate(10, -30);
                ctx.rotate(attackAnim * 0.1); 
                ctx.fillRect(0, -20, 2, 40); 
                ctx.fillStyle = '#eee';
                ctx.fillRect(-2, -25, 6, 10); 
                ctx.restore();
            } else {
                ctx.fillRect(5, -30 + bounce, 2, 30); 
            }
        }

        ctx.restore();
        
        // Mini HP Bar
        if (!this.dead && this.hp < this.maxHp) {
            ctx.fillStyle = 'red';
            ctx.fillRect(this.x - 10, this.y - 60, 20, 4);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(this.x - 10, this.y - 60, 20 * (this.hp / this.maxHp), 4);
        }
    }
}

class General extends Entity {
    constructor(x, y, team, name) {
        super(x, y, team, 'general');
        this.name = name;
        this.maxHp = team === 1 ? 500 : 800;
        this.hp = this.maxHp;
        this.mp = 100;
        this.width = 60;
        this.height = 100;
        this.attackRange = 80;
        this.attackSpeed = 40;
        this.scale = 1.5;
        this.isHorse = true;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        const dir = (this.target) ? (this.target.x > this.x ? 1 : -1) : (this.team === 1 ? 1 : -1);
        ctx.scale(dir * this.scale, this.scale);

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath();
        ctx.ellipse(0, 0, 30, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        if (this.dead) {
            ctx.rotate(Math.PI / 2);
            ctx.globalAlpha = 0.5;
        }

        const bounce = this.state === 'move' ? Math.sin(this.animFrame * 0.2) * 3 : 0;
        
        // Horse
        ctx.fillStyle = this.team === 1 ? '#fff' : '#321'; 
        ctx.fillRect(-20, -30 + bounce, 50, 20); 
        ctx.fillRect(-15 + bounce, -10, 8, 15); 
        ctx.fillRect(15 - bounce, -10, 8, 15); 
        ctx.fillRect(20, -45 + bounce, 15, 20); 
        ctx.fillRect(30, -50 + bounce, 12, 10); 

        // Rider
        ctx.fillStyle = this.team === 1 ? '#006600' : '#440000'; 
        ctx.fillRect(-5, -55 + bounce, 15, 30); 
        
        // Head
        ctx.fillStyle = '#ffccaa';
        ctx.fillRect(-2, -65 + bounce, 10, 10);
        
        // Weapon
        const attackRot = this.state === 'attack' && this.attackCooldown > 20 ? Math.PI/2 : -Math.PI/4;
        ctx.save();
        ctx.translate(5, -50 + bounce);
        ctx.rotate(attackRot);
        
        ctx.fillStyle = '#421';
        ctx.fillRect(0, -40, 3, 80);
        
        ctx.fillStyle = '#cceecc';
        if (this.team === 1) {
             ctx.beginPath();
             ctx.moveTo(3, -40);
             ctx.arc(3, -40, 15, 0, Math.PI, true);
             ctx.fill();
        } else {
            ctx.fillRect(-10, -40, 23, 5);
            ctx.fillRect(10, -50, 3, 20);
        }
        ctx.restore();

        ctx.restore();
    }
}

class Particle {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; 
        this.life = 30;
        this.vx = (Math.random() - 0.5) * 5;
        this.vy = (Math.random() - 0.5) * 5;
        this.size = Math.random() * 5 + 2;
    }

    update(gameSpeed) {
        this.x += this.vx * gameSpeed;
        this.y += this.vy * gameSpeed;
        this.life -= gameSpeed;
        if (this.type === 'wave') {
            this.size += 5 * gameSpeed;
            this.x += 15 * gameSpeed;
        }
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life / 30);
        if (this.type === 'blood') ctx.fillStyle = '#aa0000';
        else if (this.type === 'spark') ctx.fillStyle = '#ffff00';
        else if (this.type === 'wave') {
            ctx.strokeStyle = '#88ccff';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 50, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            return;
        } 

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

/**
 * Main Game Logic
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();

        CONFIG.groundY = this.canvas.height - 180;

        this.camera = new Camera(this.canvas.width, this.canvas.height);
        this.entities = [];
        this.projectiles = [];
        this.particles = [];
        this.floatingTexts = [];
        
        this.state = 'intro'; 
        this.timer = 99;
        this.frameCount = 0;
        this.introTime = 0;
        this.gameSpeed = 1.0;
        this.menuOpen = false;
        
        // Cache Background Assets (Fix Flickering)
        this.bgMountains = [];
        this.bgClouds = [];
        this.bgCity = [];
        this.initBackgroundAssets();

        this.setupInputs();
        this.drawPortraits();
        this.initBattle();
        this.loop();
        
        // Timer
        setInterval(() => {
            if (this.state === 'battle' && this.timer > 0 && !this.menuOpen) {
                this.timer--;
                document.getElementById('timer').innerText = this.timer;
            }
        }, 1000);
    }
    
    initBackgroundAssets() {
        // Generate Mountains
        let x = 0;
        while(x < 3000) {
            this.bgMountains.push({
                x: x,
                y: CONFIG.groundY - 100 - Math.random()*150
            });
            x += 100;
        }
        this.bgMountains.push({x: 3000, y: CONFIG.groundY}); // Close loop
        
        // Generate City Battlements
        for(let i=0; i<20; i++) {
            this.bgCity.push(100 + i*100);
        }

        // Generate Clouds
        for(let i=0; i<5; i++) {
            this.bgClouds.push({
                x: Math.random() * 2000,
                y: Math.random() * 300,
                w: 100 + Math.random() * 100,
                speed: 0.2 + Math.random() * 0.2
            });
        }
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    setupInputs() {
        window.addEventListener('resize', () => this.resize());

        // Mouse Drag
        this.canvas.addEventListener('mousedown', e => {
            this.camera.isDragging = true;
            this.camera.lastMouseX = e.clientX;
        });
        window.addEventListener('mousemove', e => {
            if (this.camera.isDragging) {
                const dx = e.clientX - this.camera.lastMouseX;
                this.camera.x -= dx;
                this.camera.lastMouseX = e.clientX;
            }
        });
        window.addEventListener('mouseup', () => this.camera.isDragging = false);
        
        // Touch
        this.canvas.addEventListener('touchstart', e => {
            this.camera.isDragging = true;
            this.camera.lastMouseX = e.touches[0].clientX;
        });
        this.canvas.addEventListener('touchmove', e => {
            if (this.camera.isDragging) {
                const dx = e.touches[0].clientX - this.camera.lastMouseX;
                this.camera.x -= dx;
                this.camera.lastMouseX = e.touches[0].clientX;
            }
        });
        this.canvas.addEventListener('touchend', () => this.camera.isDragging = false);
        
        // Keyboard (Space to toggle menu)
        window.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                e.preventDefault();
                this.toggleMenu();
            }
        });
    }

    toggleMenu() {
        if (this.state !== 'battle' && this.state !== 'cutscene') return;
        
        this.menuOpen = !this.menuOpen;
        const overlay = document.getElementById('command-overlay');
        
        if (this.menuOpen) {
            this.gameSpeed = 0.1; // Slow Motion
            overlay.classList.add('active');
        } else {
            this.gameSpeed = 1.0; // Normal
            overlay.classList.remove('active');
        }
    }

    drawPortraits() {
        // Draw Zhang Fei
        const p1 = document.getElementById('p1-portrait').getContext('2d');
        p1.fillStyle = '#333'; p1.fillRect(0,0,300,150);
        p1.fillStyle = '#ccaa88'; p1.beginPath(); p1.arc(150, 75, 40, 0, Math.PI*2); p1.fill();
        p1.fillStyle = '#000'; p1.beginPath(); p1.arc(150, 80, 45, 0, Math.PI, false); p1.stroke();
        p1.lineWidth = 5; p1.stroke();
        p1.fillStyle = '#000'; p1.fillRect(120, 50, 60, 10);
        
        // Draw Lu Bu
        const p2 = document.getElementById('p2-portrait').getContext('2d');
        p2.fillStyle = '#333'; p2.fillRect(0,0,300,150);
        p2.fillStyle = '#ccaa88'; p2.beginPath(); p2.arc(150, 75, 40, 0, Math.PI*2); p2.fill();
        p2.fillStyle = '#500'; p2.fillRect(110, 10, 80, 50);
        p2.fillStyle = 'red'; p2.fillRect(145, 0, 10, 40);
    }

    initBattle() {
        this.playerGen = new General(200, CONFIG.groundY, 1, "張飛");
        this.entities.push(this.playerGen);
        this.enemyGen = new General(1800, CONFIG.groundY, 2, "呂布");
        this.entities.push(this.enemyGen);

        // Infantry (Front)
        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 5; j++) {
                this.entities.push(new Entity(50 + i * 30, CONFIG.groundY - 60 + j * 30, 1, 'infantry'));
                this.entities.push(new Entity(1900 - i * 30, CONFIG.groundY - 60 + j * 30, 2, 'infantry'));
            }
        }
        
        // Archers (Back)
        for (let j = 0; j < 5; j++) {
            // Player Archers (Left side, further back)
            this.entities.push(new Entity(0, CONFIG.groundY - 60 + j * 30, 1, 'archer'));
            // Enemy Archers (Right side, further back)
            this.entities.push(new Entity(1950, CONFIG.groundY - 60 + j * 30, 2, 'archer'));
        }
        
        this.updateUI();
    }
    
    spawnProjectile(x, y, tx, ty, team) {
        this.projectiles.push(new Projectile(x, y, tx, ty, team));
    }

    sendCommand(cmd) {
        if (this.state !== 'battle' && this.state !== 'cutscene') return;
        
        this.playerGen.command = cmd;
        this.entities.forEach(e => {
            if (e.team === 1 && !e.dead) {
                e.command = cmd;
            }
        });
        
        this.addFloatingText(this.playerGen.x, this.playerGen.y - 100, "軍令: " + (cmd === 'charge' ? '突擊' : (cmd==='hold'?'待命':'後退')), '#ffff00');
    }

    castSkill() {
        if (this.state !== 'battle' && this.state !== 'cutscene') return;
        if (this.playerGen.mp < 30) {
            this.addFloatingText(this.playerGen.x, this.playerGen.y - 80, "技力不足!", "#999");
            return;
        }
        
        this.playerGen.mp -= 30;
        this.state = 'cutscene';
        
        const overlay = document.getElementById('cutscene-overlay');
        const text = document.getElementById('skill-text');
        overlay.style.display = 'flex';
        text.innerText = "半月斬";
        text.style.animation = 'none';
        void text.offsetWidth; 
        text.style.animation = 'skillZoom 2s ease-out';

        setTimeout(() => {
            overlay.style.display = 'none';
            this.state = 'battle';
            this.executeSkillEffect('crescent', this.playerGen.x, this.playerGen.y, 1);
        }, 2000);
    }
    
    executeSkillEffect(type, x, y, team) {
        if (type === 'crescent') {
             for(let i=0; i<10; i++) {
                 setTimeout(() => {
                    this.particles.push(new Particle(x + 50 + i*20, y, 'wave'));
                 }, i * 50);
             }
             
             setTimeout(() => {
                 this.entities.forEach(e => {
                     if (e.team !== team && !e.dead && Math.abs(e.y - y) < 100) {
                         e.takeDamage(50);
                     }
                 });
                 this.camera.y = 10;
                 setTimeout(() => this.camera.y = 0, 200);
             }, 500);
        }
    }

    addFloatingText(x, y, text, color) {
        this.floatingTexts.push({x, y, text, color, life: 60});
    }

    updateUI() {
        document.getElementById('p1-hp').style.width = (this.playerGen.hp / this.playerGen.maxHp * 100) + '%';
        document.getElementById('p1-hp-text').innerText = Math.max(0, this.playerGen.hp);
        document.getElementById('p1-mp').style.width = this.playerGen.mp + '%';
        const p1Troops = this.entities.filter(e => e.team === 1 && !e.dead && !e.isHorse).length;
        document.getElementById('p1-troops').innerText = p1Troops;

        document.getElementById('p2-hp').style.width = (this.enemyGen.hp / this.enemyGen.maxHp * 100) + '%';
        document.getElementById('p2-hp-text').innerText = Math.max(0, this.enemyGen.hp);
        const p2Troops = this.entities.filter(e => e.team === 2 && !e.dead && !e.isHorse).length;
        document.getElementById('p2-troops').innerText = p2Troops;
        
        if (this.playerGen.dead) this.endGame('敗北');
        else if (this.enemyGen.dead) this.endGame('勝利');
    }

    endGame(result) {
        this.state = 'end';
        const overlay = document.getElementById('start-overlay');
        overlay.style.opacity = 1;
        overlay.querySelector('.battle-start-text').innerText = result;
    }

    loop() {
        const gs = this.state === 'cutscene' ? 0 : this.gameSpeed;
        
        this.ctx.fillStyle = CONFIG.colors.bgSky;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.drawBackground();

        this.ctx.save();
        this.ctx.translate(-this.camera.x, -this.camera.y);

        this.camera.update();

        if (this.state === 'intro') {
            this.introTime++;
            if (this.introTime < 100) this.camera.targetX = 0;
            else if (this.introTime < 250) this.camera.x += (CONFIG.worldWidth - this.canvas.width - this.camera.x) * 0.02;
            else if (this.introTime < 350) {} 
            else {
                this.camera.x += (0 - this.camera.x) * 0.05;
                if (Math.abs(this.camera.x) < 10) {
                    this.state = 'battle';
                    const startOverlay = document.getElementById('start-overlay');
                    startOverlay.style.opacity = 1;
                    setTimeout(() => startOverlay.style.opacity = 0, 1500);
                }
            }
        }

        this.entities.sort((a, b) => a.y - b.y);

        this.entities.forEach(e => {
            if (this.state === 'battle' || this.state === 'cutscene') e.update(this.entities, gs);
            e.draw(this.ctx);
        });
        
        // Update Projectiles
        this.projectiles = this.projectiles.filter(p => !p.update(gs));
        this.projectiles.forEach(p => {
             // Check collisions
             if (p.life > 0) {
                 this.entities.forEach(e => {
                     if (e.team !== p.team && !e.dead && Math.abs(e.x - p.x) < 20 && Math.abs(e.y - p.y) < 40) {
                         e.takeDamage(10);
                         p.life = 0; // Destroy arrow
                     }
                 });
             }
             if(p.life > 0) p.draw(this.ctx);
        });

        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => {
            p.update(gs);
            p.draw(this.ctx);
        });

        this.ctx.textAlign = 'center';
        this.floatingTexts = this.floatingTexts.filter(t => t.life > 0);
        this.floatingTexts.forEach(t => {
            t.life -= gs;
            t.y -= 1 * gs;
            this.ctx.fillStyle = t.color;
            this.ctx.font = 'bold 20px "Noto Serif TC"';
            this.ctx.fillText(t.text, t.x, t.y);
        });

        this.ctx.restore();
        this.updateUI();

        this.frameCount++;
        requestAnimationFrame(() => this.loop());
    }

    drawBackground() {
        // Distant Mountains (Parallax 0.5) - now cached
        this.ctx.save();
        this.ctx.translate(-this.camera.x * 0.2, 0);
        this.ctx.fillStyle = '#445566';
        this.ctx.beginPath();
        this.ctx.moveTo(0, CONFIG.groundY - 100);
        
        this.bgMountains.forEach(pt => this.ctx.lineTo(pt.x, pt.y));

        this.ctx.lineTo(3000, CONFIG.groundY);
        this.ctx.lineTo(0, CONFIG.groundY);
        this.ctx.fill();
        this.ctx.restore();
        
        // Clouds
        this.ctx.save();
        this.ctx.fillStyle = 'rgba(255,255,255,0.4)';
        this.bgClouds.forEach(c => {
             // Simple loop wrap logic
             let drawX = (c.x + this.frameCount * c.speed) % 3000 - 500 - this.camera.x * 0.1;
             this.ctx.beginPath();
             this.ctx.ellipse(drawX, c.y, c.w, 30, 0, 0, Math.PI*2);
             this.ctx.fill();
        });
        this.ctx.restore();

        // City Walls (Parallax 0.8) - now cached logic
        this.ctx.save();
        this.ctx.translate(-this.camera.x * 0.5, 0);
        this.ctx.fillStyle = '#776655';
        this.ctx.fillRect(100, CONFIG.groundY - 200, 2000, 200);
        
        this.bgCity.forEach(x => {
            this.ctx.fillRect(x, CONFIG.groundY - 220, 50, 20);
        });
        this.ctx.restore();

        // Ground (Main layer)
        this.ctx.save();
        this.ctx.translate(-this.camera.x, 0);
        this.ctx.fillStyle = CONFIG.colors.bgGround;
        this.ctx.fillRect(0, CONFIG.groundY - 50, CONFIG.worldWidth, this.canvas.height);
        
        // Grass patches
        this.ctx.fillStyle = CONFIG.colors.bgGrass;
        // Simple modulo based rendering for grass to avoid storage or random flickers
        for(let i=0; i<20; i++) {
             // Pseudo random based on index
             let yOff = (i * 13217) % 50;
             this.ctx.fillRect(i * 150, CONFIG.groundY + yOff, 50, 20);
        }
        this.ctx.restore();
    }
}

window.onload = () => {
    window.game = new Game();
};

</script>
</body>
</html>